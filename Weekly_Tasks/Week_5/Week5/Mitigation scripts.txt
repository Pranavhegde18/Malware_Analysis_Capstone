# Get a list of all running processes
$processes = Get-Process

# Initialize an empty array to store information about potential malicious processes
$maliciousProcesses = @()

# Iterate over each process and check for suspicious characteristics
foreach ($process in $processes) {
    # Get the process details
    $processDetails = Get-WmiObject -Class Win32_Process -Filter "ProcessId = $($process.Id)"

    # Check if the process is running from a suspicious location
    if ($processDetails.ExecutablePath -match 'C:\\Windows\\System32\\' -and $processDetails.ExecutablePath -notlike '*explorer.exe') {
        $maliciousProcesses += $processDetails
    }

    # Check if the process has a suspicious name
    if ($process.ProcessName -match 'svchost' -or $process.ProcessName -match 'powershell' -or $process.ProcessName -match 'wscript') {
        $maliciousProcesses += $processDetails
    }

    # Check if the process is making suspicious network connections
    $connections = Get-NetTCPConnection -OwningProcess $process.Id -ErrorAction SilentlyContinue
    if ($connections -ne $null) {
        $maliciousConnections = $connections | Where-Object { $_.State -eq 'ESTABLISHED' -and $_.RemoteAddress -ne '127.0.0.1' }
        if ($maliciousConnections) {
            $maliciousProcesses += $processDetails
        }
    }
}

# Display information about the malicious processes
foreach ($maliciousProcess in $maliciousProcesses) {
    Write-Host "Process Name: $($maliciousProcess.Name)"
    Write-Host "Executable Path: $($maliciousProcess.ExecutablePath)"
    Write-Host "Command Line: $($maliciousProcess.CommandLine)"
    Write-Host "Parent Process ID: $($maliciousProcess.ParentProcessId)"
    Write-Host "---------------------------------------------"
}



###########################################



# Get the list of processes related to encryption
$encryptionProcesses = Get-Process | Where-Object { $_.Modules.ModuleName -match 'crypt32.dll' -or $_.Modules.ModuleName -match 'cryptbase.dll' }

# Stop each encryption-related process
foreach ($process in $encryptionProcesses) {
    Write-Host "Stopping process $($process.ProcessName) (ID: $($process.Id))..."
    Stop-Process -Id $process.Id -Force
}

Write-Host "Encryption-related processes stopped successfully."




############################################




# Path to the executable file
$executablePath = "C:\Path\To\Your\Executable.exe"

# Run the 'strings' command to extract strings from the executable
$stringsOutput = & "strings" -n 6 -nobanner $executablePath

# Specify the malicious strings to check for
$maliciousStrings = @(
    "malware",
    "virus",
    "backdoor",
    "exploit"
)

# Initialize an empty array to store the malicious strings found
$foundMaliciousStrings = @()

# Iterate over each malicious string and check if it exists in the 'strings' output
foreach ($maliciousString in $maliciousStrings) {
    if ($stringsOutput -match $maliciousString) {
        $foundMaliciousStrings += $maliciousString
    }
}

# Display the results
if ($foundMaliciousStrings) {
    Write-Host "Potentially malicious strings found in the executable:"
    foreach ($foundMaliciousString in $foundMaliciousStrings) {
        Write-Host "- $foundMaliciousString"
    }
} else {
    Write-Host "No potentially malicious strings found in the executable."
}






############################################





# Path to the PEStudio executable
$pestudioPath = "C:\Path\To\PEStudio\PEStudio.exe"

# Path to the executable file to analyze
$executablePath = "C:\Path\To\Your\Executable.exe"

# Run PEStudio in command-line mode and save the analysis report to a temporary file
$reportPath = [System.IO.Path]::GetTempFileName()
& $pestudioPath -file $executablePath -quiet -export -string -json -saveReport $reportPath

# Load the analysis report as JSON
$reportContent = Get-Content -Raw -Path $reportPath | ConvertFrom-Json

# Extract information on flagged strings
$flaggedStrings = $reportContent.FlaggedStrings | Where-Object { $_.Flag -ne "None" }

# Extract information on flagged exports
$flaggedExports = $reportContent.FlaggedExports | Where-Object { $_.Flag -ne "None" }

# Display the results
if ($flaggedStrings) {
    Write-Host "Flagged Strings:"
    foreach ($flaggedString in $flaggedStrings) {
        Write-Host "- String: $($flaggedString.Value)"
        Write-Host "  Flag: $($flaggedString.Flag)"
    }
} else {
    Write-Host "No flagged strings found."
}

if ($flaggedExports) {
    Write-Host "Flagged Exports:"
    foreach ($flaggedExport in $flaggedExports) {
        Write-Host "- Export: $($flaggedExport.Value)"
        Write-Host "  Flag: $($flaggedExport.Flag)"
    }
} else {
    Write-Host "No flagged exports found."
}

# Clean up the temporary report file
Remove-Item -Path $reportPath -Force





#######################################################





# Start Process Hacker
Start-Process -FilePath "C:\Path\To\ProcessHacker.exe" -PassThru | Out-Null

# Wait for Process Hacker to start (adjust the sleep time if needed)
Start-Sleep -Seconds 5

# Get the Process Hacker window handle
$processHackerHandle = (Get-Process -Name ProcessHacker).MainWindowHandle

# Activate the Process Hacker window
Add-Type -TypeDefinition @"
using System;
using System.Runtime.InteropServices;

public class Win32Api
{
    [DllImport("user32.dll")]
    public static extern bool SetForegroundWindow(IntPtr hWnd);
}
"@
[Win32Api]::SetForegroundWindow($processHackerHandle) | Out-Null

# Get the list of processes in Process Hacker
$processes = Get-Process | Where-Object { $_.MainWindowTitle -eq "Process Hacker" }

# Process the process information as needed
foreach ($process in $processes) {
    Write-Host "Process Name: $($process.Name)"
    Write-Host "Process ID: $($process.Id)"
    Write-Host "Memory Usage: $($process.WorkingSet64 / 1MB) MB"
    Write-Host "---------------------------------------------"
}

# Close Process Hacker
Stop-Process -Name ProcessHacker -Force




###############################################


# Get the list of running processes
$processes = Get-Process

# Initialize an empty array to store malicious process names
$maliciousProcesses = @()

# Iterate over each process and check for malware detection
foreach ($process in $processes) {
    # Check if the process is detected as malware by Microsoft Defender
    $detectionResult = Get-MpThreatDetection -ThreatID $process.Id -ErrorAction SilentlyContinue

    if ($detectionResult) {
        $maliciousProcesses += $process.Name
    }
}

# Stop malicious processes
foreach ($maliciousProcess in $maliciousProcesses) {
    Write-Host "Stopping malicious process: $maliciousProcess"
    Stop-Process -Name $maliciousProcess -Force
}

# Scan and remove malicious files
$maliciousFiles = Get-MpThreatCatalog -ThreatID "*" -ErrorAction SilentlyContinue

if ($maliciousFiles) {
    foreach ($file in $maliciousFiles) {
        $filePath = $file.FilePath

        # Quarantine the file
        Write-Host "Quarantining file: $filePath"
        Start-MpThreatRemoval -ThreatID $file.ThreatID -Remove -Force
    }
} else {
    Write-Host "No malicious files detected."
}




#######################################################




# Specify the path to the folder containing the DLL files
$folderPath = "C:\Path\To\DLLs"

# Get all DLL files in the specified folder
$dllFiles = Get-ChildItem -Path $folderPath -Filter "*.dll" -File

# Iterate over each DLL file
foreach ($dllFile in $dllFiles) {
    # Verify the Microsoft signature of the DLL file
    $signature = Get-AuthenticodeSignature -FilePath $dllFile.FullName

    # Check if the DLL file has a valid Microsoft signature
    if ($signature.Status -eq "Valid") {
        Write-Host "Valid signature: $($dllFile.Name)"
        # Execute the DLL file
        # Add your code to run or load the DLL as needed
    }
    else {
        Write-Host "Invalid signature: $($dllFile.Name)"
        # You can add additional actions for handling DLLs with invalid signatures
    }
}





##############################################



# Specify the name of the malicious process
$maliciousProcessName = "KeyloggerProcess.exe"

# Specify the DLL and function names to monitor
$dllName = "user32.dll"
$functionNames = @("GetKeyboardLayout", "GetKeyState")

# Start monitoring process execution
$processWatcher = Register-WmiEvent -Query "SELECT * FROM Win32_ProcessStartTrace WHERE ProcessName='$maliciousProcessName'" -Action {
    $processId = $event.SourceEventArgs.NewEvent.ProcessID

    # Get the list of loaded modules for the process
    $modules = Get-WmiObject -Class Win32_ProcessModule -Filter "ProcessID = $processId" | Select-Object -ExpandProperty Name

    # Check if any monitored DLLs are loaded
    foreach ($module in $modules) {
        if ($module -eq $dllName) {
            # Detected the malicious DLL, perform actions as needed
            Write-Host "Malicious DLL detected: $module"
            # Add your code to flag or block the process
            break
        }
    }
}

# Wait for user input to stop monitoring
Write-Host "Monitoring process execution. Press Enter to stop..."
$null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")

# Clean up the event watcher
$processWatcher.EventConsumer.Dispose()
$processWatcher.Dispose()




#####################################################




# Define the DLL function names to check
$functionNames = @("GetKeyboardLayout", "GetKeyState")

# Get all loaded modules in the current PowerShell session
$loadedModules = Get-Process -Id $PID | Select-Object -ExpandProperty Modules

# Iterate over each loaded module
foreach ($module in $loadedModules) {
    $modulePath = $module.FileName

    # Load the module into memory
    $loadedModule = [System.Reflection.Assembly]::LoadFrom($modulePath)

    # Check if the module contains any of the specified function names
    foreach ($functionName in $functionNames) {
        if ($loadedModule.GetTypes() | ForEach-Object { $_.GetMethods() } | Where-Object { $_.Name -eq $functionName }) {
            Write-Host "Potential malicious use of function $functionName in module $modulePath"
        }
    }
}




#######################################################





# Monitor file access
$watcher = New-Object System.IO.FileSystemWatcher
$watcher.Path = "C:\Path\To\Monitor"
$watcher.IncludeSubdirectories = $true
$watcher.EnableRaisingEvents = $true

$createdHandler = Register-ObjectEvent $watcher "Created" -Action {
    $file = $Event.SourceEventArgs.FullPath
    Write-Host "File Created: $file"
    # Add your custom logic to check for suspicious file access
}

$changedHandler = Register-ObjectEvent $watcher "Changed" -Action {
    $file = $Event.SourceEventArgs.FullPath
    Write-Host "File Changed: $file"
    # Add your custom logic to check for suspicious file access
}

# Monitor network connections
$networkConnections = Get-NetTCPConnection
$filteredConnections = $networkConnections | Where-Object { $_.RemoteAddress -like "x.x.x.x" }
if ($filteredConnections) {
    Write-Host "Suspicious network connections found:"
    $filteredConnections
    # Add your custom logic to handle suspicious network connections
}

# Monitor system events
$systemEvents = Get-WinEvent -LogName "System" -MaxEvents 100 |
    Where-Object { $_.Level -ge 3 -and $_.ProviderName -ne "Microsoft-Windows-Security-Auditing" }
if ($systemEvents) {
    Write-Host "Suspicious system events found:"
    $systemEvents
    # Add your custom logic to handle suspicious system events
}

# Wait for events
try {
    while ($true) {
        Start-Sleep -Seconds 1
    }
}
finally {
    Unregister-Event -SourceIdentifier $createdHandler.Name
    Unregister-Event -SourceIdentifier $changedHandler.Name
}





##############################################################



# Define the path to the executable file
$executablePath = "C:\Path\To\Executable.exe"

# Calculate the hash of the executable file
$hashAlgorithm = [System.Security.Cryptography.SHA256]::Create()
$executableBytes = [System.IO.File]::ReadAllBytes($executablePath)
$hashBytes = $hashAlgorithm.ComputeHash($executableBytes)
$hash = [System.BitConverter]::ToString($hashBytes).Replace("-", "").ToLower()

# Construct the VirusTotal API URL
$apiUrl = "https://www.virustotal.com/api/v3/files/$hash"

# Specify your VirusTotal API key
$apiKey = "Your_VirusTotal_API_Key"

# Set the headers for the API request
$headers = @{
    "x-apikey" = $apiKey
    "Content-Type" = "application/json"
}

# Submit the file hash to VirusTotal for analysis
$response = Invoke-RestMethod -Uri $apiUrl -Method Get -Headers $headers

# Check the detection results
if ($response.data.attributes.last_analysis_stats.malicious -gt 0) {
    Write-Host "The file has been flagged by $response.data.attributes.last_analysis_stats.malicious / $response.data.attributes.last_analysis_stats.total AV engines."
    # Stop the process executable
    Stop-Process -Path $executablePath -Force
}
else {
    Write-Host "The file is clean. No detections found."
}



####################################################




# Specify the IP address to check
$ipAddress = "127.0.0.1"

# Specify your abuseIPDB API key
$apiKey = "Your_abuseIPDB_API_Key"

# Construct the API URL
$apiUrl = "https://api.abuseipdb.com/api/v2/check?ipAddress=$ipAddress"

# Set the headers for the API request
$headers = @{
    "Key" = $apiKey
    "Accept" = "application/json"
}

# Submit the request to abuseIPDB
$response = Invoke-RestMethod -Uri $apiUrl -Headers $headers

# Check the response for abuse reports
if ($response.data.abuseConfidenceScore -gt 0) {
    Write-Host "The IP address $ipAddress is flagged as malicious."
    Write-Host "Abuse Confidence Score: $($response.data.abuseConfidenceScore)"
    Write-Host "Country: $($response.data.countryName)"
    # Add more details as needed
}
else {
    Write-Host "The IP address $ipAddress is not flagged as malicious."
}



####################################################




# Path to the YARA executable
$yaraPath = "C:\Path\To\YARA.exe"

# Path to the YARA rule file
$yaraRuleFile = "C:\Path\To\RuleFile.yar"

# Path to the PEStudio executable
$peStudioPath = "C:\Path\To\PEStudio.exe"

# Path to the file to scan
$targetFile = "C:\Path\To\TargetFile.exe"

# Run YARA command to scan the target using the specified rule file
$result = & $yaraPath $yaraRuleFile $targetFile

# Process the YARA scan result
if ($result) {
    Write-Host "IOC detected in the target:"
    foreach ($line in $result) {
        Write-Host $line
    }

    # Take additional actions here, such as logging or response actions

    # Run PEStudio to analyze the target file
    $peStudioOutput = & $peStudioPath /scan $targetFile

    # Extract flags and exports from the PEStudio output
    $flags = $peStudioOutput | Select-String -Pattern "Flags\s+:\s+(.+)" | ForEach-Object { $_.Matches.Groups[1].Value }
    $exports = $peStudioOutput | Select-String -Pattern "Exports\s+:\s+(.+)" | ForEach-Object { $_.Matches.Groups[1].Value }

    # Store the flags and exports for future references
    $flags | Out-File -FilePath "C:\Path\To\Flags.txt"
    $exports | Out-File -FilePath "C:\Path\To\Exports.txt"
}
else {
    Write-Host "No IOC detected in the target."
}




#########################################












