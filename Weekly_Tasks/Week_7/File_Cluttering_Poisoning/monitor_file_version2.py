import os
import time
import hashlib
import logging
import ctypes
import platform
import struct

# Windows Constants for ReadDirectoryChangesW
FILE_LIST_DIRECTORY = 0x0001
FILE_NOTIFY_CHANGE_FILE_NAME = 0x00000001
FILE_NOTIFY_CHANGE_DIR_NAME = 0x00000002
FILE_NOTIFY_CHANGE_SIZE = 0x00000004

# Import wintypes explicitly
from ctypes import wintypes

def hash_file(file_path):
    # Generate a hash of the file content (using SHA256)
    sha256 = hashlib.sha256()
    with open(file_path, "rb") as file:
        for chunk in iter(lambda: file.read(4096), b""):
            sha256.update(chunk)
    return sha256.hexdigest()

def stop_activity(directory):
    print(f"Stopping activity in directory: {directory}")
    # Add your code here to stop file creation or saving, e.g., disable permissions or move files to a quarantine folder.

def monitor_directory(directory, log_file, max_files_per_interval=10, interval=10):
    file_states = {}

    # Setup logging configuration
    logging.basicConfig(filename=log_file, level=logging.INFO,
                        format='%(asctime)s - %(message)s', datefmt='%Y-%m-%d %H:%M:%S')

    # Windows-specific setup for ReadDirectoryChangesW
    if platform.system() == 'Windows':
        ReadDirectoryChangesW = ctypes.windll.kernel32.ReadDirectoryChangesW
        ReadDirectoryChangesW.restype = wintypes.BOOL
        ReadDirectoryChangesW.argtypes = [
            wintypes.HANDLE,
            ctypes.wintypes.LPVOID,
            wintypes.DWORD,
            wintypes.BOOL,
            wintypes.DWORD,
            wintypes.LPDWORD,
            ctypes.wintypes.LPVOID,
            ctypes.wintypes.LPVOID,
        ]

    # Get a handle to the directory for monitoring
    directory_handle = ctypes.windll.kernel32.CreateFileW(
        directory,
        FILE_LIST_DIRECTORY,
        win32file.FILE_SHARE_READ | win32file.FILE_SHARE_WRITE | win32file.FILE_SHARE_DELETE,
        None,
        win32file.OPEN_EXISTING,
        win32file.FILE_FLAG_BACKUP_SEMANTICS,
        None
    )

    while True:
        new_files_counter = 0

        # Monitor the directory for changes
        if platform.system() == 'Windows':
            results = ctypes.create_string_buffer(4096)
            ReadDirectoryChangesW(
                directory_handle,
                ctypes.byref(results),
                4096,
                True,
                FILE_NOTIFY_CHANGE_FILE_NAME | FILE_NOTIFY_CHANGE_DIR_NAME | FILE_NOTIFY_CHANGE_SIZE,
                None,
                None,
                None
            )

            buffer_pos = 0
            while buffer_pos < len(results.raw):
                action, file_name_length, _ = struct.unpack_from('III', results.raw, buffer_pos)
                buffer_pos += struct.calcsize('III')

                file_name = struct.unpack_from(f'{file_name_length}s', results.raw, buffer_pos)[0].decode('utf-16')
                buffer_pos += struct.calcsize(f'{file_name_length}s')

                file_path = os.path.join(directory, file_name)
                try:
                    # Get the file's current hash
                    current_hash = hash_file(file_path)

                    # If the file is new or its content has changed
                    if file_path not in file_states or file_states[file_path] != current_hash:
                        if file_path not in file_states:
                            event = "NEW FILE"
                            new_files_counter += 1
                        else:
                            event = "FILE MODIFIED"
                        file_states[file_path] = current_hash

                        # Log the event with the timestamp
                        logging.info(f"{event} - File: {file_path}")

                        # Show real-time output
                        print(f"{event} - File: {file_path}")

                except Exception as e:
                    print(f"Error accessing {file_path}: {e}")

        # Check for deleted files and log the event
        for file_path in list(file_states.keys()):
            if not os.path.exists(file_path):
                logging.info(f"FILE DELETED - File: {file_path}")
                del file_states[file_path]

                # Show real-time output
                print(f"FILE DELETED - File: {file_path}")

        # Check for excessive file creation or download activity
        if new_files_counter >= max_files_per_interval:
            logging.warning(f"WARNING: Excessive file creation or download activity detected. {new_files_counter} new files created within {interval} seconds.")
            print(f"WARNING: Excessive file creation or download activity detected. {new_files_counter} new files created within {interval} seconds.")
            stop_activity(directory)

        # Wait for the specified interval before checking the directory again
        time.sleep(interval)

if __name__ == "__main__":
    target_directory = "D:\\Files\\Week9\\File_Cluttering_Poisoning"  # Change this to the directory you want to monitor
    log_file = "D:\\Files\\Week9\\logs\\file_activity_log.log"  # Change this to the desired log file path

    # Set proper file permissions to limit access to the log file
    os.umask(0o077)

    # Check for elevated privileges on Windows
    if os.name == 'nt' and not ctypes.windll.shell32.IsUserAnAdmin():
        print("This script requires elevated privileges. Please run as an administrator.")
        exit(1)

    # Start monitoring the directory with file integrity checking and activity detection
    print(f"Monitoring directory: {target_directory}")
    monitor_directory(target_directory, log_file)
