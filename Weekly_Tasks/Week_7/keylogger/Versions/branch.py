import keystone
import capstone
import pefile

def get_base_address(pe_file_path):
    pe = pefile.PE(pe_file_path)
    return pe.OPTIONAL_HEADER.ImageBase

def calculate_branching_complexity(file_path):
    with open(file_path, 'rb') as file:
        binary_code = file.read()

    # Initialize the disassembler engines
    ks = keystone.Ks(keystone.KS_ARCH_X86, keystone.KS_MODE_32)
    md = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_32)

    # Assemble the binary code to get the bytecode
    try:
        address = get_base_address(file_path)
        bytecode, _ = ks.asm(binary_code, hex(address))  # Start address for assembly
    except keystone.KsError as e:
        print("Assembly Error:", e)
        return -1

    # Define a set to keep track of executed addresses
    executed_addresses = set()

    # Perform execution simulation to calculate branching complexity
    address = 0x1000  # Start address for execution
    branching_instructions = 0

    for insn in md.disasm(bytecode, address):
        # Check if the current address is already executed (loop or branch)
        if insn.address in executed_addresses:
            break

        # Add the current address to the set of executed addresses
        executed_addresses.add(insn.address)

        # Check if the instruction is a control flow instruction (e.g., conditional jump or loop)
        if insn.mnemonic in {'jz', 'jnz', 'jbe', 'jb', 'jae', 'ja', 'je', 'jne', 'jl', 'jge', 'jle', 'jg', 'loop', 'loope', 'loopne'}:
            branching_instructions += 1
            # Calculate the destination address of the branch
            destination = insn.address + insn.size + insn.operands[0].value.imm
            # Add the destination address to the set of executed addresses
            executed_addresses.add(destination)

    return branching_instructions

# Example usage
file_to_analyze = "infect.exe"
branching_complexity = calculate_branching_complexity(file_to_analyze)
print("Branching Complexity:", branching_complexity)
