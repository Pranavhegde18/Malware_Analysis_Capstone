#include <iostream>
#include <windows.h>
#include <tlhelp32.h> // Include this for THREADENTRY32

namespace string_helper {
    // Define your string helper functions here
}

namespace process_helper {
    // Define your process helper functions here
}

// Function to check if a window title contains keywords indicating a debugger
bool IsDebuggerWindowTitle(const std::wstring& title) {
    return (title.find(L"dbg") != std::wstring::npos ||
            title.find(L"debugger") != std::wstring::npos);
}

DWORD g_dwDebuggerProcessId = -1;

BOOL CALLBACK EnumWindowsProc(HWND hwnd, LPARAM lParam) {
    DWORD dwProcessId = *(PDWORD)lParam;

    DWORD dwWindowProcessId;
    GetWindowThreadProcessId(hwnd, &dwWindowProcessId);

    if (dwProcessId == dwWindowProcessId) {
        std::wstring wsWindowTitle(GetWindowTextLengthW(hwnd) + 1, L'\0');
        GetWindowTextW(hwnd, &wsWindowTitle[0], wsWindowTitle.size());

        if (IsDebuggerWindowTitle(wsWindowTitle)) {
            g_dwDebuggerProcessId = dwProcessId;
            return FALSE;
        }
    }

    return TRUE;
}

bool IsDebuggerProcess(DWORD dwProcessId) {
    EnumWindows(EnumWindowsProc, reinterpret_cast<LPARAM>(&dwProcessId));
    return g_dwDebuggerProcessId == dwProcessId;
}

bool SuspendDebuggerThread() {
    THREADENTRY32 ThreadEntry = { sizeof(THREADENTRY32) };

    DWORD dwParentProcessId = process_helper::GetParentProcessId(GetCurrentProcessId());
    if (-1 == dwParentProcessId)
        return false;

    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, dwParentProcessId);
    if (hSnapshot != INVALID_HANDLE_VALUE) {
        if (Thread32First(hSnapshot, &ThreadEntry)) {
            do {
                if ((ThreadEntry.th32OwnerProcessID == dwParentProcessId) && IsDebuggerProcess(dwParentProcessId)) {
                    HANDLE hThread = OpenThread(THREAD_SUSPEND_RESUME, FALSE, ThreadEntry.th32ThreadID);
                    if (hThread) {
                        SuspendThread(hThread);
                        CloseHandle(hThread); // Don't forget to close the handle
                    }
                    break;
                }
            } while (Thread32Next(hSnapshot, &ThreadEntry));
        }
        CloseHandle(hSnapshot); // Close the snapshot handle
    }

    return false;
}

int main() {
    // Call your functions here and handle their return values
    return 0;
}
